## Отчет
* Реализация операторов инициализации, кроссовера и мутации
  * При реализации инициализации индивида использовался метод .nextDouble(), который генерирует псевдослечайное число в диапазоне от 0 до 1. Чтобы привести к необходимой области определения [-5, 5] результат метода * 11 - 5. Код представлен в файле `MyFactory.java`
  * Реализация кроссовера. Возможно два варианта реализации алгоритма кроссовера. Первый - дискретный, в нем мы просто берем часть от одного родителя, а часть от другого. Второй - арифметический; в данном случае часть мы берем от первого родителя, а часть считаем по формуле z_i = alpha*x_i+(1-alpha)*y_i. Поскольку дискретный вариант является частным случаем арифметического (при alpha = 1), реализуем общий случай. На вход подается два родителя и i - целое число, означающее количество генов, которые будут перемешаны между парами. Для определения генов которые будут перемешаны, мы генерируем список длины i, значениями которого являются неповторяющиеся целые числа, лежащие в диапазоне [0, размер родителей -1]. Так мы получаем идексы генов, к которым будем применять формулу. На выходе получаем список с новыми решениями. Код представлен в файле `MyCrossober.java`
  * При реализации мутации необходимо было решить какие индивиды и как будут меняться. Код представлен в файле `MyMutation.java`
* Проведем эксперименты
  * int demention = 2
* увеличим размерности проблемы
  * int populationSize <100
  * int generetions <10 000

| Размер проблемы | Размер популяции | Количество итераций | Результаты |
|:---------------:|:----------------:| :------------------:|:---------: |
| 2     | a    | a |a| 
| 10     | a |   a |a|
| 20  | a         |    a |a|
|50|a|a |a |
|100| a|a |a |

### Ответы на вопросы
1. Что важнее кроссовер или мутация?
2. Как влияет значение параметра "размерность популяции" на производительность и эффективность алгоритма?
3. Важно ли знать область определения переменных целевой функции?

