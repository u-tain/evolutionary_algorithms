## Отчет
### Реализация операторов инициализации, кроссовера и мутации
  * При реализации инициализации индивида использовался метод .nextDouble(), который генерирует псевдослечайное число в диапазоне от 0 до 1. Чтобы привести к необходимой области определения [-5, 5] результат метода * 11 - 5. Код представлен в файле `MyFactory.java`
  * Реализация кроссовера. Возможно два варианта реализации алгоритма кроссовера. Первый - дискретный, в нем мы просто берем часть от одного родителя, а часть от другого. Второй - арифметический; в данном случае часть мы берем от первого родителя, а часть считаем по формуле z_i = alpha*x_i+(1-alpha)*y_i. Поскольку дискретный вариант является частным случаем арифметического (при alpha = 1), реализуем общий случай. На вход подается два родителя и i - целое число, означающее количество генов, которые будут перемешаны между парами. Для определения генов которые будут перемешаны, мы генерируем список длины i, значениями которого являются неповторяющиеся целые числа, лежащие в диапазоне [0, размер родителей -1]. Так мы получаем идексы генов, к которым будем применять формулу. На выходе получаем список с новыми решениями. Код представлен в файле `MyCrossober.java`
  * При реализации мутации необходимо было решить какие индивиды и как будут меняться. Выберем индивидов с вероятностью 1/population size. Чтобы это реализовать для каждого индивида сгенерируем число от 0 до 1 и сравниваем с 1/population size. Если сгенерированное число меньше, то в индивиде будет мутация. Определение того, какие гены индивида будут мутировать определяется похожим образом, только сравнивать будем с 1/dimension. Сама мутация реализована равномерной, т.е. изменение значения гена происходит в рамках нижней и верхней границы области определения. Код представлен в файле `MyMutation.java`
### Проведем эксперименты
  * int demention = 2
  * В ходе проведенных эксперементов подбирались параметр alpha.
  * С увеличением количетва шагов алгоритм становился более устойчивым, т.е. стабильнее достигал удовлетворительного результата. Так же были попытки варьировать вероятность выбора в мутации, но к видимым улучшениям не удалось прийти.
  * Подобранный параметр alpha = 0.61
### Увеличим размерности проблемы
  * int populationSize < 100
  * int generetions < 10 000
  * в случае с размером проблемы 50 и 100 для сходимости алгоритма была увеличена вероятность мутации в индивиде и гене до 8/population size и 2/dimension.

| Размер проблемы | Размер популяции | Количество итераций | Результаты |
|:---------------:|:----------------:| :------------------:|:---------: |
| 2               | 15               | 25                  | 9.71       | 
| 10              | 45               | 1000                | 9.704      |
| 20              | 60               | 3500                | 9.665      |
| 50              | 80               | 8000                | 9.708      |
| 100             | 99               | 9999                | 8.985      |

### Ответы на вопросы
1. Что важнее кроссовер или мутация?
2. Как влияет значение параметра "размер популяции" на производительность и эффективность алгоритма?
3. Важно ли знать область определения переменных целевой функции?

