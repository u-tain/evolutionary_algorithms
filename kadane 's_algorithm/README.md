## Отчет
Алгоритм Кадане - алгоритм, решающий задачу поиска максимальной суммы последовательных элементов массива. Он состоит из следующих шагов:
1. инициализация локальной суммы loc_sum = 0
2. инициализация глобальной суммы glob_sum = 0
3. повторять для каждого элемента (el) массива:
    * обновить значение локальной суммы: loc_sum += el
    * если loc_sum <0: loc_sum = 0
    * если loc_sum > glob_sum: glob_sum = loc_sum
4. результат работы алгоритма = glob_sum

Для реализации был выбран ЯП C++. Сложность данного алгоритма = O(n), поскольку для его выполнения необходимо один раз полностью перебрать массив (n - длинна массива). Для нагрузочного тестирования было сгенерировано по 100 массивов следующих длин: 10, 100, 1000 , 10000, 50000, 100000, 500000, 1000000 и измерено время работы алгоритма. В качестве итогового времени для каждой длины массива вычислялось среднее значение из результатов всех ста тестов.

Первый вариант алгоритма был реализован с помощью класса vector (в коде представлено фунцией kadane1). В качестве оптимизации длина массива стала передаваться в функцию, а не вычисляться внутри. Также добавление текущего элемента к локальной сумме происходит во время сравнения с нулем, таким образом локальная сумма обновляется не больше 1го раза для каждого элемента массива.(в коде представлено фунцией kadane2) После преобразований таже были проведены нагрузочные тесты.

Кроме того вместо класса vector предлагается использовать стандартный динамический массив. Предыдущие шаги оптимизации остаются.(в коде представлено фунцией kadane3) Сложность алгоритма останется прежней. Для данной версии были проведены нагрузочные тесты.

Результат тестов:

![1](https://user-images.githubusercontent.com/43996253/218338247-714c6468-8b75-4536-b6fe-fb8ae4621f90.PNG)

Из тестов видно, что, начиная с массивов длины 10000, использовать стандартные динамические массивы выгоднее по времени работы. 

Ссылка на репозиторий с реализацией: https://github.com/u-tain/evolutionary_algorithms/tree/main/kadane%20's_algorithm
